/**
 * Adds an item to the end of the queue
 */
void QueueEnqueue(Queue q, Item it) {
	// TODO
	//When array is full, need to expand.
	if (q->size == q->capacity) {
		//Rearrange array using index.
		//Rearranging onto temp array.
		int temp_array[q->capacity];
		int counter = q->frontIndex;
		int temp_counter = 0;
		while (temp_counter <= q->capacity) {
			if (counter == q->capacity) {
				counter = 0;
			}
			temp_array[temp_counter] = q->items[counter];
			counter++;
			temp_counter++;
		}

		//Copy sorted order from temp array back to items.
		counter = 0;
		while (counter < q->capacity) {
			q->items[counter] = temp_array[counter];
			counter++;
		}
		q->frontIndex = 0;
		
		//Capacity times 2
		q->capacity = q->capacity * 2;
		q->items = realloc(q->items, q->capacity * sizeof(Item));
		/*if (q->items == NULL) {
			fprintf(stderr, "couldn't resize Queue\n");
		}*/

		//Adding new input.
		q->items[q->size] = it;
		
	}
	
	//When array is not full.
	else {
	//Need to loop back to the front. 
		if ((q->frontIndex + q->size) >= q->capacity && q->frontIndex != 0) {
			int new_index = q->frontIndex + q->size - q->capacity;
			q->items[new_index] = it;
		}
		
		else {
			q->items[(q->frontIndex + q->size)] = it;
			
		}
	}
	q->size = q->size + 1;
}

/**
 * Removes an item from the front of the queue and returns it
 * Assumes that the queue is not empty
 */

Item QueueDequeue(Queue q) {
	
	q->size = q->size - 1;
	if (q->frontIndex == (q->capacity - 1)) {
		int temp = q->items[q->capacity - 1];
		q->items[q->capacity - 1] = 0;
		q->frontIndex = 0;
		return temp;
	}
	else {
		q->frontIndex = q->frontIndex + 1;
		int temp = q->items[q->frontIndex - 1];
		q->items[q->frontIndex - 1] = 0;
		return temp;
	}
	
}
